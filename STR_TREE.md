STR_TREE analysis
=================

Generated by GitHub Copilot with the help of Claude Sonnet 4.5. If you plan to use str_tree outside of peexports, read this! - Bojan.

# `str_tree` - String Binary Search Tree

## Overview

`str_tree.c` implements a **binary search tree (BST)** data structure that stores strings with associated metadata. It's used by pexports to efficiently store and look up exported symbol names from PE files.

## Purpose in pexports

The tree structure allows:
- **Fast lookups** of previously seen symbols (O(log n) average case)
- **Automatic deduplication** - prevents duplicate symbol entries
- **Sorted storage** - strings are automatically kept in alphabetical order

---

## Data Structure

```c
typedef struct str_tree {
    char *s;                    // The string key (dynamically allocated copy)
    void *extra;                // Additional data associated with the string
    struct str_tree *left;      // Left child (strings < current node)
    struct str_tree *right;     // Right child (strings > current node)
} str_tree;
```

**Properties:**
- **Binary Search Tree ordering**: For any node, all strings in the left subtree are lexicographically smaller, and all strings in the right subtree are larger
- **String ownership**: The tree owns its strings (uses `strdup()`)
- **Generic payload**: The `extra` pointer can store any additional data

---

## API Documentation

### 1. `str_tree_add()`

**Signature:**
```c
str_tree *str_tree_add(str_tree **root, const char *s, void *extra);
```

**Description:**  
Adds a new string to the binary search tree. If the string already exists, it is added as a duplicate node (the tree allows duplicates on the right subtree).

**Parameters:**
- `root` - Pointer to the root pointer of the tree (double pointer allows modification of the root)
- `s` - The string to add (will be copied with `strdup()`)
- `extra` - Optional pointer to additional data associated with this string

**Returns:**
- Pointer to the newly created or inserted node
- `NULL` if memory allocation fails

**Behavior:**
- **Recursive insertion** following BST rules:
  - `strcmp(s, node->s) < 0` â†’ insert in left subtree
  - `strcmp(s, node->s) >= 0` â†’ insert in right subtree
- Creates a new leaf node if tree is empty or insertion point is reached
- **Duplicates are allowed** - they go to the right subtree

**Example:**
```c
str_tree *root = NULL;
str_tree_add(&root, "ExportedFunc", NULL);
str_tree_add(&root, "AnotherFunc", some_data_ptr);
```

**Time Complexity:**
- Average: O(log n)
- Worst case (unbalanced): O(n)

---

### 2. `str_tree_find()`

**Signature:**
```c
str_tree *str_tree_find(str_tree *node, const char *s);
```

**Description:**  
Searches for a string in the binary search tree using standard BST lookup.

**Parameters:**
- `node` - Root node of the tree (or subtree) to search
- `s` - The string to find

**Returns:**
- Pointer to the node containing the string if found
- `NULL` if the string is not in the tree

**Behavior:**
- **Recursive search** following BST rules:
  - `strcmp(s, node->s) == 0` â†’ found, return node
  - `strcmp(s, node->s) < 0` â†’ search left subtree
  - `strcmp(s, node->s) > 0` â†’ search right subtree
- If the string exists as a duplicate, returns the **first occurrence** encountered

**Example:**
```c
str_tree *found = str_tree_find(root, "ExportedFunc");
if (found) {
    printf("Found: %s\n", found->s);
    // Access extra data: found->extra
}
```

**Time Complexity:**
- Average: O(log n)
- Worst case (unbalanced): O(n)

---

### 3. `new_leaf()` (Internal/Private)

**Signature:**
```c
static str_tree *new_leaf(const char *s, void *extra);
```

**Description:**  
Internal helper function that creates a new leaf node.

**Parameters:**
- `s` - String to store (will be copied)
- `extra` - Additional data pointer

**Returns:**
- Pointer to newly allocated node
- `NULL` if memory allocation fails

**Memory Management:**
- Allocates memory for the node structure
- Duplicates the string with `strdup()`
- Initializes left and right pointers to `NULL`
- **Error handling**: If `strdup()` fails, frees the node and returns `NULL`

---

## Memory Management

âš ï¸ **Important**: The current implementation has **no memory cleanup function**!

**Missing functionality:**
- No `str_tree_free()` or `str_tree_destroy()` function
- Memory leaks will occur if the tree is not manually freed

**Workaround needed:**
```c
// You would need to implement something like this:
void str_tree_free(str_tree *node) {
    if (node == NULL)
        return;
    str_tree_free(node->left);
    str_tree_free(node->right);
    free(node->s);
    free(node);
}
```

---

## Usage in pexports

In the context of pexports, this tree is likely used to:

1. **Store exported symbols** from DLL/PE files
2. **Check for duplicates** before adding symbols
3. **Associate metadata** with each symbol (ordinals, calling conventions, etc.) via the `extra` pointer
4. **Maintain sorted order** for generating `.def` files

---

## Limitations

1. **No balancing** - Tree can become unbalanced with sorted input (degrades to O(n))
2. **No deletion** - No function to remove nodes
3. **No memory cleanup** - No function to free the entire tree
4. **Allows duplicates** - Duplicates go to the right, might not be desired behavior
5. **No traversal** - No in-order, pre-order, or post-order traversal functions

---

## Potential Improvements

```c
// Suggested additions:

// Free entire tree
void str_tree_free(str_tree *node);

// In-order traversal (alphabetical order)
void str_tree_traverse(str_tree *node, void (*callback)(str_tree *));

// Count nodes
int str_tree_count(str_tree *node);

// Check if tree is balanced
int str_tree_height(str_tree *node);
```

---

This is a minimal, functional BST implementation suitable for pexports' use case of symbol management. For a small to moderate number of symbols, it performs adequately despite lacking balancing! ðŸŒ²
